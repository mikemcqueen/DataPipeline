* Txn_complete
* The question is, why do I even need a txn::complete_t wrapper for msg_ptr_t
  if all of the processing is happening on the awaitable side? shouldn't just
  using complete_txn_awaitable be enough, and just mark txn as !started there?
* The purpose I am currently using txn::complete_t for is to contain a result_code
  on error. Which requires the client to check the out() msg type, which is what
  I was trying to avoid in the first place. And seems somewhat unnecessary if I
  can just shove an	'rc' into the promise.





Still some work left to make it work with live client:
* Transform method primarily.
* Then I also want to change all kMsg / kTxn constants to char*.
* Figure out how to get dp::Dispatch gain aware of ui::msg without
  bringing in Ui as a dependency. SendEvent? PostMessage + Ui::Handler_t?
  * SendEvent + UI::Handler_t. Maybe I should add a special "Event" stage
  that gets checked first for SendEvent calls.
* Figure out some nice clean way for the handler promise object
  to know that a "transaction has started." This has two benefits
  1) Simplifies started_ state to a boolean in TxSellItems.
  2) Simplifies all txn handlers to not have to include logic
     for "have we started yet?" If I can cram it in an awaitable,
	 or something. 
	 Maybe there needs to be an outer invisible "idle state" "handler"
	 coro function that auto-activates, and waits for a txn_start,
	 or something?
	
	
So here's what I'm thinking.  Take TxBuySellItems and call it TxHandler.
Insert handler as Interpreter.  No need to insert buy/sell/setprice interpreters (yet)
as they don't do anything.
m_txHandler is owned by Eq2BrokerImpl.
I already have some kind of a TransactionStart event. Can I just use that?
Do I have to register the Tx handler somehow for that?
The	goal:
  * user input: t sell_item name price
  * send start txn msg. or otherwise manufacture and post a message for TxHandler to see.
    ** Can't I just call SendEvent and have an EventHandler on TxnHaandler
  * TxHandler (eventually, maybe, TransactionManager) can own the tx_sell coroutine.
  * if tx_sell is not active, "activate" it whatever that means. set a flag basically.
  * StartAcquiring(true). Auto-Stops after first acquire data. Set a flag to discard
    any subsequent events?
  * in MessageHandler, if tx is active, send_event to tx_sell.
    * NO: But! we want this to run on tx_sells thread. Or, the "current txn" thread.
	* NO: For now, there is only one, so can probably just create one in TxHandler.
	* NO: See old new thing for thread switch trick awaitable.
  * when txn done.. what does that even mean? Who's waiting on this coro?
  * YES: I think actually need to do the "send event" to coro from within a thread,
    and not have the coro switch threads from caller.
  * NO: be nice to figure out how to put a stop-token to use here. but maybe the
	  YES MAYBE: txn_start/stop is my own mechanism?
  * YES: question is why do i actually need another thread here? why can't i just
    commandeer the PM::MessageThread for consuming 1 message?
  * I mean, in theory, it'd be nice, but for first PoC it's probably not necessary.
  * All of the threading shit needs to be standardized anyway. I don't want to
    be in the quagmire of threading shit right now. I want to make the coroutine
	transaction PoC work, then I can start thinking about how that interops with
	threads.
  * So, after MessageHandler handles:
    * if txn_complete message, "disable" tx_sell. 
	* else, call StartAcquiring(true) again
  * I may need/want to write some transformer from Legacy to New msg data,
    For BrokerSell and BrokerSetPrice.
  * 

g_pDisplay

static charsets in DcrTrades_t.
overall, clean up Dcr* of charset cruft

DcrWindow.cpp, remove inline code from .h

widget IDs as empty enum class + constexpr + MakeId
review some of the enable_if/concepts ideas for restricting MakeId to specific 
types (WindowId_t, WidgetId_t, EventId_t, etc.)
	maybe i can use typeid(T) == typeid(type1) || typeid(type2) etc.
	probably need to use a magic value in the scoped enum to enable this.

TableWindow should not inherit from TabWindow. A window *has a* a table,
not *is a* table.

I think the word transaction is wrong. State would also be wrong. This is a container
for a set of states really.  or a container for a state machine?

Move TableInfo_t.h to DcrLib. DcrTableTypes?

Ui::Window:
  --can be moved elsewhere:
  * anything that takes a CSurface, maybe? New derived type: Virtual_t, parallel
    type of WithHandle_t, emphasizing "CSurface-based" recognition.

BrokerWindow::IsTabWindow shit. goes.

saw weird "out of pool items (71)" error.  71?  WTF? I know tesseract is slow but jeez.

Probably want TiBroker* to do some text massaging. that means a co-routine-loop sourced
synchronous screenshot will want to "translate" then "interpret". and there will probably
be some commonality between TiBrokerBuy, TiBrokerSell. price text for example

broker_sell2.bmp:
BrokerSell::ValidateClient(): Line (0) @ (218, 297) doesn't match

SetLastOrigin is not being called consistently for all window types?
Ui::WindowId_t WindowType_t::LastOriginMatchAll is broken if we have more than 1 window_ids
Window::Base_t optional<POINT> last origin?
Unique_ptr<CSurface> in all windows (for all bmps)
	
c++20: * == done(ish)
	range_for (as_const? or just const auto) whereever const_iterator is defined. read up on as_const vs. const auto
	public + delete instead of private copy/assignment/move
	enum class
	constexpr
		static const -> constexpr (generally)
	typedef -> using
	char* param -> string_view
	bool get(Struct* pResult) -> optional<Struct> get()
